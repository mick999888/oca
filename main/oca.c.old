#include <stdio.h>
#include <string.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/adc.h"
#include "esp_adc_cal.h"
#include "esp_timer.h"

#define ARRAY_SIZE 100000000 // Define the size of the array

// global variables
int iFirstUnlock = 0;

void adc_init() {
	    // Configure ADC
	    adc1_config_width(ADC_WIDTH_BIT_12);
	    adc1_config_channel_atten(ADC1_CHANNEL_0, ADC_ATTEN_DB_11);

	    // Check if Two Point or Vref are burned into eFuse
	    esp_adc_cal_characteristics_t *adc_chars = calloc(1, sizeof(esp_adc_cal_characteristics_t));
	    esp_adc_cal_value_t val_type = esp_adc_cal_characterize(ADC_UNIT_1, ADC_ATTEN_DB_11, ADC_WIDTH_BIT_12, 1100, adc_chars);
	    if (val_type == ESP_ADC_CAL_VAL_EFUSE_VREF) {
	       printf("eFuse Vref: Calibration scheme used.\n");
	    } else if (val_type == ESP_ADC_CAL_VAL_EFUSE_TP) {
	       printf("Two Point: Calibration scheme used.\n");
	    } else {
	       printf("Default Vref: Calibration scheme used.\n");
	    }
}

void read_adc_task(void *pvParameter) {
	// uint32_t uiCount = 0;
	uint32_t uiLevelDiff  = 0;
	uint32_t uiTimeBuff  = 0;
	uint32_t uiTimeFinal = 0;
	uint32_t uiTimeIdle = 0;
	uint32_t uiCount = 0;

	struct telegram
	{
		uint32_t uiLogic;
		uint32_t uiTime;
	};

	struct telegram single[ARRAY_SIZE]; 


	int      iSet    = 0;
	size_t n; 

    while (1) {

        // get digital input level
        uint32_t adc_reading = adc1_get_raw(ADC1_CHANNEL_0); // GPIO36
		uiLevelDiff = 4095 - adc_reading;

        // get running time stamp
		uiTimeBuff = esp_timer_get_time();


		if (uiLevelDiff > 20) {

			// unlock here for first time
			if (iFirstUnlock == 0) {
				iFirstUnlock = 1;
			}

			// detect rising for the first time
			if ((iSet == 0) && (iFirstUnlock == 1)) {
				iSet = 1;
				// this is normal run 
				uiTimeFinal = uiTimeBuff - uiTimeFinal;

            // "set=1" as long as peaks come along
			} else if (iSet == 1) {
				uiTimeFinal = uiTimeBuff - uiTimeFinal;
				uiCount++;
				single[uiCount].uiLogic = uiLevelDiff;
				single[uiCount].uiTime  = uiTimeBuff;
			}
		} 
		
		else 
		
		{
			if (iFirstUnlock == 1) {
				uiTimeIdle = esp_timer_get_time() - uiTimeFinal;
				if (iSet == 1)
				{
					uiCount = 0;
					iSet = 0;
				}
				else if (iSet == 0)
				{
					if (uiTimeIdle > 2000)
					{
						// print array
						n = sizeof(single) / sizeof(single[0]);
						for (int aa = 0; aa < n; aa++)
						{
							printf("%ld %ld \n", single[aa].uiLogic, single[aa].uiTime);
							//printf("hallo");
						}
					}
				}

			}
		}


			//printf("%ld/%ld|", uiLevelDiff, uiFinal);

    }
}

void app_main(void)
{
	// Initialize ADC
    adc_init();
    // Create a task to read from ADC and print
    xTaskCreatePinnedToCore(read_adc_task, "read_adc_task", 2048, NULL, 5, NULL, 0);
}
